[
    {
        "label": "runpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "runpy",
        "description": "runpy",
        "detail": "runpy",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "ArrayLike",
        "importPath": "numpy.typing",
        "description": "numpy.typing",
        "isExtraImport": true,
        "detail": "numpy.typing",
        "documentation": {}
    },
    {
        "label": "ArrayLike",
        "importPath": "numpy.typing",
        "description": "numpy.typing",
        "isExtraImport": true,
        "detail": "numpy.typing",
        "documentation": {}
    },
    {
        "label": "ArrayLike",
        "importPath": "numpy.typing",
        "description": "numpy.typing",
        "isExtraImport": true,
        "detail": "numpy.typing",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "cuboid_mesher",
        "importPath": "surface_mesher",
        "description": "surface_mesher",
        "isExtraImport": true,
        "detail": "surface_mesher",
        "documentation": {}
    },
    {
        "label": "cuboid_mesher_with_resolution",
        "importPath": "surface_mesher",
        "description": "surface_mesher",
        "isExtraImport": true,
        "detail": "surface_mesher",
        "documentation": {}
    },
    {
        "label": "cylinder_mesher_radial",
        "importPath": "surface_mesher",
        "description": "surface_mesher",
        "isExtraImport": true,
        "detail": "surface_mesher",
        "documentation": {}
    },
    {
        "label": "cylinder_mesher_square_centered",
        "importPath": "surface_mesher",
        "description": "surface_mesher",
        "isExtraImport": true,
        "detail": "surface_mesher",
        "documentation": {}
    },
    {
        "label": "disk_mesher_radial",
        "importPath": "surface_mesher",
        "description": "surface_mesher",
        "isExtraImport": true,
        "detail": "surface_mesher",
        "documentation": {}
    },
    {
        "label": "circumference_edges",
        "importPath": "surface_mesher",
        "description": "surface_mesher",
        "isExtraImport": true,
        "detail": "surface_mesher",
        "documentation": {}
    },
    {
        "label": "disk_mesher_square_centered",
        "importPath": "surface_mesher",
        "description": "surface_mesher",
        "isExtraImport": true,
        "detail": "surface_mesher",
        "documentation": {}
    },
    {
        "label": "convert_2d_face_to_3d",
        "importPath": "surface_mesher",
        "description": "surface_mesher",
        "isExtraImport": true,
        "detail": "surface_mesher",
        "documentation": {}
    },
    {
        "label": "quad_faces_from_edges",
        "importPath": "surface_mesher",
        "description": "surface_mesher",
        "isExtraImport": true,
        "detail": "surface_mesher",
        "documentation": {}
    },
    {
        "label": "mesh_between_edges",
        "importPath": "surface_mesher",
        "description": "surface_mesher",
        "isExtraImport": true,
        "detail": "surface_mesher",
        "documentation": {}
    },
    {
        "label": "rectangle_perimeter",
        "importPath": "surface_mesher",
        "description": "surface_mesher",
        "isExtraImport": true,
        "detail": "surface_mesher",
        "documentation": {}
    },
    {
        "label": "revolve_curve_along_path",
        "importPath": "surface_mesher.revolve",
        "description": "surface_mesher.revolve",
        "isExtraImport": true,
        "detail": "surface_mesher.revolve",
        "documentation": {}
    },
    {
        "label": "circular_revolve",
        "importPath": "surface_mesher.revolve",
        "description": "surface_mesher.revolve",
        "isExtraImport": true,
        "detail": "surface_mesher.revolve",
        "documentation": {}
    },
    {
        "label": "sphere_mesher_from_projection",
        "importPath": "surface_mesher.sphere",
        "description": "surface_mesher.sphere",
        "isExtraImport": true,
        "detail": "surface_mesher.sphere",
        "documentation": {}
    },
    {
        "label": "sphere_mesher_from_radial",
        "importPath": "surface_mesher.sphere",
        "description": "surface_mesher.sphere",
        "isExtraImport": true,
        "detail": "surface_mesher.sphere",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"surface-mesher\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "base = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"surface-mesher\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"surface-mesher\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"surface-mesher\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV_PROMPT\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV_PROMPT\"] = \"surface-mesher\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_root_hkey",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "create_shortcut",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_special_folder_path",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location: str) -> str:\n    location = os.path.abspath(location)\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(\n            f'Path \"{location}\" is not an existing directory!'\n        )\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python -m pywin32_postinstall -install\n    * or (shorter but you don't have control over which python environment is used)\n    > pywin32_postinstall -install\n    You need to execute this script, with a '-install' parameter,\n    to ensure the environment is setup correctly to install COM objects, services, etc.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\nclass Tee:\n    def __init__(self, file):\n        self.f = file",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [project_root] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nsite_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "cuboid_mesher",
        "kind": 2,
        "importPath": "src.surface_mesher.cuboid",
        "description": "src.surface_mesher.cuboid",
        "peekOfCode": "def cuboid_mesher(x_coords: ArrayLike, y_coords: ArrayLike, z_coords: ArrayLike) -> np.ndarray:\n    \"\"\"\n    Generate a full cuboid surface mesh using explicit coordinate arrays along each axis.\n    This function creates quadrilateral surface faces based on 1D coordinate arrays for the\n    x, y, and z axes. The surface mesh includes all six sides of the cuboid spanned by\n    the given coordinates. Vertex order for each quad is counter-clockwise.\n    Parameters\n    ----------\n    x_coords : ArrayLike of float\n        1D strictly increasing array of x-axis positions for vertical planes (YZ-facing).",
        "detail": "src.surface_mesher.cuboid",
        "documentation": {}
    },
    {
        "label": "cuboid_mesher_with_resolution",
        "kind": 2,
        "importPath": "src.surface_mesher.cuboid",
        "description": "src.surface_mesher.cuboid",
        "peekOfCode": "def cuboid_mesher_with_resolution(\n    length: float, width: float, height: float, origin: tuple[float, float, float] = (0.0, 0.0, 0.0), resolution: int | tuple[int, int, int] = (1, 1, 1)\n) -> np.ndarray:\n    \"\"\"\n    Generate a 3D surface mesh of a cuboid with quadrilateral faces based on resolution.\n    Parameters\n    ----------\n    length : float\n        Length of the cuboid along the x-axis.\n    width : float",
        "detail": "src.surface_mesher.cuboid",
        "documentation": {}
    },
    {
        "label": "cylinder_mesher_radial",
        "kind": 2,
        "importPath": "src.surface_mesher.cylinder",
        "description": "src.surface_mesher.cylinder",
        "peekOfCode": "def cylinder_mesher_radial(radius: float, height: float, radial_resolution: int, segment_resolution: int, height_resolution: int) -> np.ndarray:\n    \"\"\"\n    Generate a triangular mesh for a closed cylinder.\n    Parameters\n    ----------\n    radius : float\n        Radius of the cylinder.\n    height : float\n        Height of the cylinder.\n    radial_resolution : int",
        "detail": "src.surface_mesher.cylinder",
        "documentation": {}
    },
    {
        "label": "cylinder_mesher_square_centered",
        "kind": 2,
        "importPath": "src.surface_mesher.cylinder",
        "description": "src.surface_mesher.cylinder",
        "peekOfCode": "def cylinder_mesher_square_centered(radius: float, height: float, radial_resolution: int, half_square_resolution: int, height_resolution: int) -> np.ndarray:\n    \"\"\"\n    Generate a mesh of a closed cylinder where the caps are based on a square-centered pattern.\n    Parameters\n    ----------\n    radius : float\n        Radius of the cylinder.\n    height : float\n        Height of the cylinder.\n    radial_resolution : int",
        "detail": "src.surface_mesher.cylinder",
        "documentation": {}
    },
    {
        "label": "circumference_edges",
        "kind": 2,
        "importPath": "src.surface_mesher.disk",
        "description": "src.surface_mesher.disk",
        "peekOfCode": "def circumference_edges(radius: float, segment_resolution: int, start_angle: float = 0, counter_clockwise: bool = True) -> np.ndarray:\n    \"\"\"\n    Generate the circumference of a circle in 2D space.\n    Parameters\n    ----------\n    radius : float\n        Radius of the circle.\n    segment_resolution : int\n        Number of segments to divide the circle into.\n    start_angle : float",
        "detail": "src.surface_mesher.disk",
        "documentation": {}
    },
    {
        "label": "disk_mesher_radial",
        "kind": 2,
        "importPath": "src.surface_mesher.disk",
        "description": "src.surface_mesher.disk",
        "peekOfCode": "def disk_mesher_radial(radius: float, radial_resolution: int, segment_resolution: int) -> np.ndarray:\n    \"\"\"\n    Generate a 2D circular mesh with curvilinear quadrilateral faces.\n    The mesh is constructed using radial and angular divisions, and\n    each cell is approximately a curved quadrilateral.\n    Parameters\n    ----------\n    radius : float\n        Radius of the disk.\n    radial_resolution : int",
        "detail": "src.surface_mesher.disk",
        "documentation": {}
    },
    {
        "label": "disk_mesher_square_centered",
        "kind": 2,
        "importPath": "src.surface_mesher.disk",
        "description": "src.surface_mesher.disk",
        "peekOfCode": "def disk_mesher_square_centered(radius: float, square_resolution: int, radial_resolution: int, square_side_radius_ratio: float = 1, square_disk_rotation: float = 0) -> np.ndarray:\n    \"\"\"\n    Generate a quadrilateral mesh for a filled disk using a square core and radial interpolation.\n    Parameters\n    ----------\n    radius : float\n        Radius of the disk. Must be positive.\n    square_resolution : int\n        Number of subdivisions along one side of the square core.\n    radial_resolution : int",
        "detail": "src.surface_mesher.disk",
        "documentation": {}
    },
    {
        "label": "convert_2d_face_to_3d",
        "kind": 2,
        "importPath": "src.surface_mesher.edge",
        "description": "src.surface_mesher.edge",
        "peekOfCode": "def convert_2d_face_to_3d(quad_2d_mesh: np.ndarray, axis: int, offset: float) -> np.ndarray:\n    \"\"\"\n    Convert a 2D quadrilateral mesh to a 3D mesh by adding a fixed coordinate.\n    \"\"\"\n    face_count = quad_2d_mesh.shape[0]\n    quads_3d_mesh = np.empty((face_count, 4, 3), dtype=float)\n    match axis:\n        case 0:\n            quads_3d_mesh[:, :, 0] = offset\n            quads_3d_mesh[:, :, 1] = quad_2d_mesh[:, :, 0]",
        "detail": "src.surface_mesher.edge",
        "documentation": {}
    },
    {
        "label": "quad_faces_from_edges",
        "kind": 2,
        "importPath": "src.surface_mesher.edge",
        "description": "src.surface_mesher.edge",
        "peekOfCode": "def quad_faces_from_edges(u_coords: ArrayLike, v_coords: ArrayLike) -> np.ndarray:\n    \"\"\"\n    Generate quadrilateral faces on a grid where one axis is fixed,\n    with counter-clockwise vertex ordering.\n    Parameters\n    ----------\n    u_coords : ArrayLike\n        Coordinates along the first varying axis (horizontal direction).\n    v_coords : ArrayLike\n        Coordinates along the second varying axis (vertical direction).",
        "detail": "src.surface_mesher.edge",
        "documentation": {}
    },
    {
        "label": "mesh_between_edges",
        "kind": 2,
        "importPath": "src.surface_mesher.edge",
        "description": "src.surface_mesher.edge",
        "peekOfCode": "def mesh_between_edges(edges: ArrayLike, radial_resolution: int) -> np.ndarray:\n    \"\"\"\n    Generate a quadrilateral mesh between two open polygonal edges by interpolation. The edges can be 2D or 3D.\n    Parameters\n    ----------\n    edges : ArrayLike, shape (2, axis_idx, vertex_idx)\n        The starting and ending boundaries to interpolate between (edge_idx, axis_idx, vertex_idx).\n    radial_resolution : int\n        Number of layers between the two edges.\n    Returns",
        "detail": "src.surface_mesher.edge",
        "documentation": {}
    },
    {
        "label": "rectangle_perimeter",
        "kind": 2,
        "importPath": "src.surface_mesher.edge",
        "description": "src.surface_mesher.edge",
        "peekOfCode": "def rectangle_perimeter(length_edge: ArrayLike, width_edge: ArrayLike) -> np.ndarray:\n    \"\"\"\n    Generate the perimeter of a rectangle.\n    Parameters\n    ----------\n    length_edge : ArrayLike\n        Length edge vertices of the rectangle along the x-axis (m, ...).\n    width_edge : ArrayLike\n        Width edge vertices of the rectangle along the y-axis (n, ...).\n    Returns",
        "detail": "src.surface_mesher.edge",
        "documentation": {}
    },
    {
        "label": "revolve_curve_along_path",
        "kind": 2,
        "importPath": "src.surface_mesher.revolve",
        "description": "src.surface_mesher.revolve",
        "peekOfCode": "def revolve_curve_along_path(curve: ArrayLike, revolve_path: ArrayLike) -> np.ndarray:\n    \"\"\"\n    Revolve a 2D curve along a given path to create a 3D surface mesh.\n    Parameters\n    ----------\n    curve : ArrayLike\n        An (n, 2) array representing (x, z) coordinates of the 2D curve.\n    revolve_path : ArrayLike\n        An (m, 2) array representing (angle in radians, radius) polar coordinates of the revolve path.\n    Returns",
        "detail": "src.surface_mesher.revolve",
        "documentation": {}
    },
    {
        "label": "circular_revolve",
        "kind": 2,
        "importPath": "src.surface_mesher.revolve",
        "description": "src.surface_mesher.revolve",
        "peekOfCode": "def circular_revolve(curve: ArrayLike, segment_resolution: int, start_angle: float = 0.0, end_angle: float = 2 * np.pi) -> np.ndarray:\n    \"\"\"\n    Revolve a 2D curve around the Z-axis counter-clockwise along a circular path.\n    Parameters\n    ----------\n    curve : ArrayLike\n        An (n, 2) array representing (radius, axial) coordinates of the curve to revolve.\n    segment_resolution : int\n        Number of angular divisions for the revolution.\n    start_angle : float, optional",
        "detail": "src.surface_mesher.revolve",
        "documentation": {}
    },
    {
        "label": "sphere_mesher_from_projection",
        "kind": 2,
        "importPath": "src.surface_mesher.sphere",
        "description": "src.surface_mesher.sphere",
        "peekOfCode": "def sphere_mesher_from_projection(radius: float, resolution: int) -> np.ndarray:\n    \"\"\"\n    Generate a quadrilateral mesh approximating a sphere using cube projection.\n    The method starts by creating a subdivided cube mesh, then normalizes and scales\n    it onto the sphere surface.\n    Parameters\n    ----------\n    radius : float\n        Radius of the resulting sphere.\n    resolution : int",
        "detail": "src.surface_mesher.sphere",
        "documentation": {}
    },
    {
        "label": "sphere_mesher_from_radial",
        "kind": 2,
        "importPath": "src.surface_mesher.sphere",
        "description": "src.surface_mesher.sphere",
        "peekOfCode": "def sphere_mesher_from_radial(\n    radius: float,\n    radial_resolution: int,\n    segment_resolution: int,\n    start_angle: float = 0,\n    end_angle: float = 2 * np.pi,\n) -> np.ndarray:\n    \"\"\"\n    Generate a mesh approximating a sphere using radial divisions.\n    The method uses spherical coordinates to create the mesh.",
        "detail": "src.surface_mesher.sphere",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_basic",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_basic():\n    x = [0.0, 1.0]\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]\n    faces = cuboid_mesher(x, y, z)\n    assert faces.shape == (6, 4, 3)\ndef test_cuboid_mesher_multiple_cells():\n    x = [0.0, 1.0, 2.0]\n    y = [0.0, 0.5, 1.0]\n    z = [0.0, 0.5, 1.0]",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_multiple_cells",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_multiple_cells():\n    x = [0.0, 1.0, 2.0]\n    y = [0.0, 0.5, 1.0]\n    z = [0.0, 0.5, 1.0]\n    faces = cuboid_mesher(x, y, z)\n    assert faces.shape == (24, 4, 3)\n@pytest.mark.parametrize(\"container_type\", [list, tuple, np.array])\ndef test_cuboid_mesher_accepts_arraylike(container_type):\n    x = container_type([0.0, 1.0, 2.0])\n    y = container_type([0.0, 1.0])",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_accepts_arraylike",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_accepts_arraylike(container_type):\n    x = container_type([0.0, 1.0, 2.0])\n    y = container_type([0.0, 1.0])\n    z = container_type([0.0, 0.5, 1.0])\n    faces = cuboid_mesher(x, y, z)\n    assert faces.shape == (16, 4, 3)\ndef test_cuboid_mesher_invalid_dimensions():\n    x = np.array([[0.0, 1.0]])  # Not 1D\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_invalid_dimensions",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_invalid_dimensions():\n    x = np.array([[0.0, 1.0]])  # Not 1D\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]\n    with pytest.raises(ValueError, match=re.escape(\"x_coords must be 1D, got shape (1, 2).\")):\n        cuboid_mesher(x, y, z)\ndef test_cuboid_mesher_too_few_values():\n    x = [0.0]\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_too_few_values",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_too_few_values():\n    x = [0.0]\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]\n    with pytest.raises(ValueError, match=\"x_coords must have at least 2 points, got 1.\"):\n        cuboid_mesher(x, y, z)\ndef test_cuboid_mesher_non_strictly_increasing():\n    x = [0.0, 1.0, 0.5]\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_non_strictly_increasing",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_non_strictly_increasing():\n    x = [0.0, 1.0, 0.5]\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]\n    with pytest.raises(ValueError, match=\"x_coords must be strictly increasing.\"):\n        cuboid_mesher(x, y, z)\ndef test_cuboid_mesher_quad_shape_and_ccw():\n    x = [0.0, 1.0]\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_quad_shape_and_ccw",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_quad_shape_and_ccw():\n    x = [0.0, 1.0]\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]\n    faces = cuboid_mesher(x, y, z)\n    assert faces.shape[1:] == (4, 3)\ndef test_cuboid_mesher_large_axis():\n    x = np.linspace(0, 1, 10)\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_large_axis",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_large_axis():\n    x = np.linspace(0, 1, 10)\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]\n    faces = cuboid_mesher(x, y, z)\n    assert faces.shape[0] == 38\ndef test_cuboid_mesher_degenerate_case_single_face_each():\n    x = [0.0, 1.0]\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_degenerate_case_single_face_each",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_degenerate_case_single_face_each():\n    x = [0.0, 1.0]\n    y = [0.0, 1.0]\n    z = [0.0, 1.0]\n    faces = cuboid_mesher(x, y, z)\n    assert faces.shape[0] == 6\n    for quad in faces:\n        assert quad.shape == (4, 3)\n# --------------------------- #\n# cuboid_mesher_with_resolution Tests #",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_with_resolution_scalar",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_with_resolution_scalar():\n    faces = cuboid_mesher_with_resolution(2.0, 1.0, 1.0, origin=(0.0, 0.0, 0.0), resolution=2)\n    assert faces.shape == (24, 4, 3)\ndef test_cuboid_mesher_with_resolution_arraylike():\n    faces = cuboid_mesher_with_resolution(2.0, 1.0, 1.0, origin=(0.0, 0.0, 0.0), resolution=[2, 1, 2])\n    assert isinstance(faces, np.ndarray)\n    assert faces.shape[1:] == (4, 3)\ndef test_cuboid_mesher_with_resolution_invalid_shape():\n    with pytest.raises(ValueError, match=\"resolution must be a single int or an array-like of three ints.\"):\n        cuboid_mesher_with_resolution(2.0, 1.0, 1.0, resolution=[2, 2])",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_with_resolution_arraylike",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_with_resolution_arraylike():\n    faces = cuboid_mesher_with_resolution(2.0, 1.0, 1.0, origin=(0.0, 0.0, 0.0), resolution=[2, 1, 2])\n    assert isinstance(faces, np.ndarray)\n    assert faces.shape[1:] == (4, 3)\ndef test_cuboid_mesher_with_resolution_invalid_shape():\n    with pytest.raises(ValueError, match=\"resolution must be a single int or an array-like of three ints.\"):\n        cuboid_mesher_with_resolution(2.0, 1.0, 1.0, resolution=[2, 2])\ndef test_cuboid_mesher_with_resolution_nonpositive():\n    with pytest.raises(ValueError, match=\"resolution must contain only positive values.\"):\n        cuboid_mesher_with_resolution(2.0, 1.0, 1.0, resolution=[2, 0, 2])",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_with_resolution_invalid_shape",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_with_resolution_invalid_shape():\n    with pytest.raises(ValueError, match=\"resolution must be a single int or an array-like of three ints.\"):\n        cuboid_mesher_with_resolution(2.0, 1.0, 1.0, resolution=[2, 2])\ndef test_cuboid_mesher_with_resolution_nonpositive():\n    with pytest.raises(ValueError, match=\"resolution must contain only positive values.\"):\n        cuboid_mesher_with_resolution(2.0, 1.0, 1.0, resolution=[2, 0, 2])",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cuboid_mesher_with_resolution_nonpositive",
        "kind": 2,
        "importPath": "tests.test_cuboid",
        "description": "tests.test_cuboid",
        "peekOfCode": "def test_cuboid_mesher_with_resolution_nonpositive():\n    with pytest.raises(ValueError, match=\"resolution must contain only positive values.\"):\n        cuboid_mesher_with_resolution(2.0, 1.0, 1.0, resolution=[2, 0, 2])",
        "detail": "tests.test_cuboid",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_radial_basic_shape",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_radial_basic_shape():\n    mesh = cylinder_mesher_radial(1.0, 2.0, 5, 8, 6)\n    assert isinstance(mesh, np.ndarray)\n    assert mesh.ndim == 3\n    assert mesh.shape[1:] == (4, 3)\ndef test_cylinder_mesher_radial_faces_count():\n    radial_res, segment_res, height_res = 5, 8, 6\n    expected_disk_faces = radial_res * segment_res\n    expected_lateral_faces = (height_res) * segment_res\n    expected_total_faces = 2 * expected_disk_faces + expected_lateral_faces",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_radial_faces_count",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_radial_faces_count():\n    radial_res, segment_res, height_res = 5, 8, 6\n    expected_disk_faces = radial_res * segment_res\n    expected_lateral_faces = (height_res) * segment_res\n    expected_total_faces = 2 * expected_disk_faces + expected_lateral_faces\n    mesh = cylinder_mesher_radial(1.0, 2.0, radial_res, segment_res, height_res)\n    assert mesh.shape[0] == expected_total_faces\ndef test_cylinder_mesher_radial_coordinate_bounds():\n    radius = 1.0\n    height = 2.0",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_radial_coordinate_bounds",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_radial_coordinate_bounds():\n    radius = 1.0\n    height = 2.0\n    mesh = cylinder_mesher_radial(radius, height, 4, 8, 5)\n    xy = mesh[..., :2]\n    r = np.linalg.norm(xy, axis=-1)\n    assert np.all(r <= radius + 1e-6)\n    z = mesh[..., 2]\n    assert np.all(z >= -height/2 - 1e-6)\n    assert np.all(z <= height/2 + 1e-6)",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_radial_various_resolutions",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_radial_various_resolutions(radial_res, segment_res, height_res):\n    mesh = cylinder_mesher_radial(1.0, 2.0, radial_res, segment_res, height_res)\n    assert mesh.shape[1:] == (4, 3)\n# ---------------------- #\n# cylinder_mesher_square_centered Tests\n# ---------------------- #\ndef test_cylinder_mesher_square_centered_basic_shape():\n    mesh = cylinder_mesher_square_centered(1.0, 2.0, 5, 4, 8)\n    assert isinstance(mesh, np.ndarray)\n    assert mesh.ndim == 3",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_square_centered_basic_shape",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_square_centered_basic_shape():\n    mesh = cylinder_mesher_square_centered(1.0, 2.0, 5, 4, 8)\n    assert isinstance(mesh, np.ndarray)\n    assert mesh.ndim == 3\n    assert mesh.shape[1:] == (4, 3)\ndef test_cylinder_mesher_square_centered_faces_count():\n    radial_res, half_square_res, height_res = 4, 3, 5\n    square_res = 2 * half_square_res\n    expected_disk_faces = (square_res * square_res) + (square_res * 4 * radial_res)\n    expected_lateral_faces = height_res * (square_res * 4)",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_square_centered_faces_count",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_square_centered_faces_count():\n    radial_res, half_square_res, height_res = 4, 3, 5\n    square_res = 2 * half_square_res\n    expected_disk_faces = (square_res * square_res) + (square_res * 4 * radial_res)\n    expected_lateral_faces = height_res * (square_res * 4)\n    expected_total_faces = 2 * expected_disk_faces + expected_lateral_faces\n    mesh = cylinder_mesher_square_centered(1.0, 2.0, radial_res, half_square_res, height_res)\n    assert mesh.shape[0] == expected_total_faces\ndef test_cylinder_mesher_square_centered_coordinate_bounds():\n    radius = 1.0",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_square_centered_coordinate_bounds",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_square_centered_coordinate_bounds():\n    radius = 1.0\n    height = 2.0\n    mesh = cylinder_mesher_square_centered(radius, height, 5, 4, 8)\n    xy = mesh[..., :2]\n    r = np.linalg.norm(xy, axis=-1)\n    assert np.all(r <= radius + 1e-6)\n    z = mesh[..., 2]\n    assert np.all(z >= -height/2 - 1e-6)\n    assert np.all(z <= height/2 + 1e-6)",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_square_centered_various_resolutions",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_square_centered_various_resolutions(radial_res, half_square_res, height_res):\n    mesh = cylinder_mesher_square_centered(1.0, 2.0, radial_res, half_square_res, height_res)\n    assert mesh.shape[1:] == (4, 3)\n# ---------------------- #\n# Error Handling Tests\n# ---------------------- #\n@pytest.mark.parametrize(\"radius\", [-1.0, 0.0])\ndef test_cylinder_mesher_radial_invalid_radius(radius):\n    with pytest.raises(ValueError, match=\"radius must be positive\"):\n        cylinder_mesher_radial(radius, 2.0, 5, 8, 6)",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_radial_invalid_radius",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_radial_invalid_radius(radius):\n    with pytest.raises(ValueError, match=\"radius must be positive\"):\n        cylinder_mesher_radial(radius, 2.0, 5, 8, 6)\n@pytest.mark.parametrize(\"radius\", [-1.0, 0.0])\ndef test_cylinder_mesher_square_centered_invalid_radius(radius):\n    with pytest.raises(ValueError, match=\"radius must be positive\"):\n        cylinder_mesher_square_centered(radius, 2.0, 5, 4, 8)\n@pytest.mark.parametrize(\"height\", [-1.0, 0.0])\ndef test_cylinder_mesher_radial_invalid_height(height):\n    with pytest.raises(ValueError, match=\"height must be positive\"):",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_square_centered_invalid_radius",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_square_centered_invalid_radius(radius):\n    with pytest.raises(ValueError, match=\"radius must be positive\"):\n        cylinder_mesher_square_centered(radius, 2.0, 5, 4, 8)\n@pytest.mark.parametrize(\"height\", [-1.0, 0.0])\ndef test_cylinder_mesher_radial_invalid_height(height):\n    with pytest.raises(ValueError, match=\"height must be positive\"):\n        cylinder_mesher_radial(1.0, height, 5, 8, 6)\n@pytest.mark.parametrize(\"height\", [-1.0, 0.0])\ndef test_cylinder_mesher_square_centered_invalid_height(height):\n    with pytest.raises(ValueError, match=\"height must be positive\"):",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_radial_invalid_height",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_radial_invalid_height(height):\n    with pytest.raises(ValueError, match=\"height must be positive\"):\n        cylinder_mesher_radial(1.0, height, 5, 8, 6)\n@pytest.mark.parametrize(\"height\", [-1.0, 0.0])\ndef test_cylinder_mesher_square_centered_invalid_height(height):\n    with pytest.raises(ValueError, match=\"height must be positive\"):\n        cylinder_mesher_square_centered(1.0, height, 5, 4, 8)\n@pytest.mark.parametrize(\"bad_res\", [0, -1])\ndef test_cylinder_mesher_radial_invalid_resolutions(bad_res):\n    with pytest.raises(ValueError):",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_square_centered_invalid_height",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_square_centered_invalid_height(height):\n    with pytest.raises(ValueError, match=\"height must be positive\"):\n        cylinder_mesher_square_centered(1.0, height, 5, 4, 8)\n@pytest.mark.parametrize(\"bad_res\", [0, -1])\ndef test_cylinder_mesher_radial_invalid_resolutions(bad_res):\n    with pytest.raises(ValueError):\n        cylinder_mesher_radial(1.0, 2.0, bad_res, 8, 6)\n    with pytest.raises(ValueError):\n        cylinder_mesher_radial(1.0, 2.0, 5, bad_res, 6)\n    with pytest.raises(ValueError):",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_radial_invalid_resolutions",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_radial_invalid_resolutions(bad_res):\n    with pytest.raises(ValueError):\n        cylinder_mesher_radial(1.0, 2.0, bad_res, 8, 6)\n    with pytest.raises(ValueError):\n        cylinder_mesher_radial(1.0, 2.0, 5, bad_res, 6)\n    with pytest.raises(ValueError):\n        cylinder_mesher_radial(1.0, 2.0, 5, 8, bad_res)\n@pytest.mark.parametrize(\"bad_res\", [0, -1])\ndef test_cylinder_mesher_square_centered_invalid_resolutions(bad_res):\n    with pytest.raises(ValueError):",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_cylinder_mesher_square_centered_invalid_resolutions",
        "kind": 2,
        "importPath": "tests.test_cylinder",
        "description": "tests.test_cylinder",
        "peekOfCode": "def test_cylinder_mesher_square_centered_invalid_resolutions(bad_res):\n    with pytest.raises(ValueError):\n        cylinder_mesher_square_centered(1.0, 2.0, bad_res, 4, 8)\n    with pytest.raises(ValueError):\n        cylinder_mesher_square_centered(1.0, 2.0, 5, bad_res, 8)\n    with pytest.raises(ValueError):\n        cylinder_mesher_square_centered(1.0, 2.0, 5, 4, bad_res)",
        "detail": "tests.test_cylinder",
        "documentation": {}
    },
    {
        "label": "test_disk_mesher_radial_basic_shape",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_disk_mesher_radial_basic_shape():\n    mesh = disk_mesher_radial(1.0, 5, 8)\n    expected_faces = 5 * 8\n    assert isinstance(mesh, np.ndarray)\n    assert mesh.shape == (expected_faces, 4, 2)\ndef test_disk_mesher_radial_output_dtype():\n    mesh = disk_mesher_radial(1.0, 3, 3)\n    assert np.issubdtype(mesh.dtype, np.floating)\ndef test_disk_mesher_radial_radius_limit():\n    mesh = disk_mesher_radial(1.0, 10, 10)",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_disk_mesher_radial_output_dtype",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_disk_mesher_radial_output_dtype():\n    mesh = disk_mesher_radial(1.0, 3, 3)\n    assert np.issubdtype(mesh.dtype, np.floating)\ndef test_disk_mesher_radial_radius_limit():\n    mesh = disk_mesher_radial(1.0, 10, 10)\n    r = np.linalg.norm(mesh, axis=-1)\n    assert np.all(r <= 1.0 + 1e-6)\n@pytest.mark.parametrize(\"radial_resolution, segment_resolution\", [\n    (1, 1),\n    (2, 4),",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_disk_mesher_radial_radius_limit",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_disk_mesher_radial_radius_limit():\n    mesh = disk_mesher_radial(1.0, 10, 10)\n    r = np.linalg.norm(mesh, axis=-1)\n    assert np.all(r <= 1.0 + 1e-6)\n@pytest.mark.parametrize(\"radial_resolution, segment_resolution\", [\n    (1, 1),\n    (2, 4),\n    (5, 10),\n])\ndef test_disk_mesher_radial_various_resolutions(radial_resolution, segment_resolution):",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_disk_mesher_radial_various_resolutions",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_disk_mesher_radial_various_resolutions(radial_resolution, segment_resolution):\n    mesh = disk_mesher_radial(1.0, radial_resolution, segment_resolution)\n    expected_faces = radial_resolution * segment_resolution\n    assert mesh.shape == (expected_faces, 4, 2)\ndef test_disk_mesher_radial_zero_radius():\n    mesh = disk_mesher_radial(0.0, 5, 8)\n    assert np.allclose(mesh, 0.0)\ndef test_disk_mesher_radial_negative_inputs():\n    with pytest.raises(ValueError, match=\"Invalid radius\"):\n        disk_mesher_radial(-1.0, 5, 5)",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_disk_mesher_radial_zero_radius",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_disk_mesher_radial_zero_radius():\n    mesh = disk_mesher_radial(0.0, 5, 8)\n    assert np.allclose(mesh, 0.0)\ndef test_disk_mesher_radial_negative_inputs():\n    with pytest.raises(ValueError, match=\"Invalid radius\"):\n        disk_mesher_radial(-1.0, 5, 5)\n    with pytest.raises(ValueError, match=\"Invalid resolution\"):\n        disk_mesher_radial(1.0, -1, 5)\n    with pytest.raises(ValueError, match=\"Invalid resolution\"):\n        disk_mesher_radial(1.0, 5, -3)",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_disk_mesher_radial_negative_inputs",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_disk_mesher_radial_negative_inputs():\n    with pytest.raises(ValueError, match=\"Invalid radius\"):\n        disk_mesher_radial(-1.0, 5, 5)\n    with pytest.raises(ValueError, match=\"Invalid resolution\"):\n        disk_mesher_radial(1.0, -1, 5)\n    with pytest.raises(ValueError, match=\"Invalid resolution\"):\n        disk_mesher_radial(1.0, 5, -3)\n# ---------------------------------- #\n# circumference_edges Tests          #\n# ---------------------------------- #",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_circumference_edges_basic",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_circumference_edges_basic():\n    circumference = circumference_edges(1.0, 12)\n    assert circumference.shape == (2, 12)\ndef test_circumference_edges_values():\n    circ = circumference_edges(1.0, 4, start_angle=0)\n    expected = np.array(\n        [[ 1. , -0.5, -0.5,  1. ],\n       [ 0. ,  0.9, -0.9, -0. ]]\n    )\n    np.testing.assert_allclose(circ.round(1), expected)",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_circumference_edges_values",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_circumference_edges_values():\n    circ = circumference_edges(1.0, 4, start_angle=0)\n    expected = np.array(\n        [[ 1. , -0.5, -0.5,  1. ],\n       [ 0. ,  0.9, -0.9, -0. ]]\n    )\n    np.testing.assert_allclose(circ.round(1), expected)\ndef test_circumference_edges_negative_radius():\n    with pytest.raises(ValueError, match=\"Invalid radius\"):\n        circumference_edges(-1.0, 12)",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_circumference_edges_negative_radius",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_circumference_edges_negative_radius():\n    with pytest.raises(ValueError, match=\"Invalid radius\"):\n        circumference_edges(-1.0, 12)\ndef test_circumference_edges_invalid_segment_resolution():\n    with pytest.raises(ValueError, match=\"Invalid segment_resolution\"):\n        circumference_edges(1.0, 0)\n# ---------------------------------- #\n# disk_mesher_square_centered Tests    #\n# ---------------------------------- #\ndef test_disk_mesher_square_centered_basic_shape():",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_circumference_edges_invalid_segment_resolution",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_circumference_edges_invalid_segment_resolution():\n    with pytest.raises(ValueError, match=\"Invalid segment_resolution\"):\n        circumference_edges(1.0, 0)\n# ---------------------------------- #\n# disk_mesher_square_centered Tests    #\n# ---------------------------------- #\ndef test_disk_mesher_square_centered_basic_shape():\n    mesh = disk_mesher_square_centered(1.0, 5, 5)\n    assert mesh.shape[1:] == (4, 2)\n    assert mesh.ndim == 3",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_disk_mesher_square_centered_basic_shape",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_disk_mesher_square_centered_basic_shape():\n    mesh = disk_mesher_square_centered(1.0, 5, 5)\n    assert mesh.shape[1:] == (4, 2)\n    assert mesh.ndim == 3\ndef test_disk_mesher_square_centered_increasing_size():\n    mesh_small = disk_mesher_square_centered(1.0, 2, 2)\n    mesh_large = disk_mesher_square_centered(1.0, 5, 5)\n    assert mesh_large.shape[0] > mesh_small.shape[0]\ndef test_disk_mesher_square_centered_invalid_inputs():\n    with pytest.raises(ValueError, match=\"radius must be positive\"):",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_disk_mesher_square_centered_increasing_size",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_disk_mesher_square_centered_increasing_size():\n    mesh_small = disk_mesher_square_centered(1.0, 2, 2)\n    mesh_large = disk_mesher_square_centered(1.0, 5, 5)\n    assert mesh_large.shape[0] > mesh_small.shape[0]\ndef test_disk_mesher_square_centered_invalid_inputs():\n    with pytest.raises(ValueError, match=\"radius must be positive\"):\n        disk_mesher_square_centered(0.0, 5, 5)\n    with pytest.raises(ValueError, match=\"square_resolution must be at least 1\"):\n        disk_mesher_square_centered(1.0, 0, 5)\n    with pytest.raises(ValueError, match=\"radial_resolution must be at least 1\"):",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_disk_mesher_square_centered_invalid_inputs",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_disk_mesher_square_centered_invalid_inputs():\n    with pytest.raises(ValueError, match=\"radius must be positive\"):\n        disk_mesher_square_centered(0.0, 5, 5)\n    with pytest.raises(ValueError, match=\"square_resolution must be at least 1\"):\n        disk_mesher_square_centered(1.0, 0, 5)\n    with pytest.raises(ValueError, match=\"radial_resolution must be at least 1\"):\n        disk_mesher_square_centered(1.0, 5, 0)\n    with pytest.raises(ValueError, match=\"square_side_radius_ratio must be in\"):\n        disk_mesher_square_centered(1.0, 5, 5, square_side_radius_ratio=0)\n    with pytest.raises(ValueError, match=\"square_side_radius_ratio must be in\"):",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_disk_mesher_square_centered_with_rotation",
        "kind": 2,
        "importPath": "tests.test_disk",
        "description": "tests.test_disk",
        "peekOfCode": "def test_disk_mesher_square_centered_with_rotation():\n    mesh_rotated = disk_mesher_square_centered(1.0, 5, 5, square_disk_rotation=np.pi/8)\n    mesh_non_rotated = disk_mesher_square_centered(1.0, 5, 5, square_disk_rotation=0)\n    assert mesh_rotated.shape == mesh_non_rotated.shape",
        "detail": "tests.test_disk",
        "documentation": {}
    },
    {
        "label": "test_convert_2d_face_to_3d_basic",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_convert_2d_face_to_3d_basic():\n    quad_2d = np.array([[[0, 0], [1, 0], [1, 1], [0, 1]]])\n    result = convert_2d_face_to_3d(quad_2d, axis=2, offset=5.0)\n    expected = np.array([[[0, 0, 5], [1, 0, 5], [1, 1, 5], [0, 1, 5]]])\n    np.testing.assert_array_equal(result, expected)\ndef test_convert_2d_face_to_3d_all_axes():\n    quad_2d = np.array([[[0, 0], [1, 0], [1, 1], [0, 1]]])\n    for axis in [0, 1, 2]:\n        result = convert_2d_face_to_3d(quad_2d, axis=axis, offset=3.5)\n        assert result.shape == (1, 4, 3)",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_convert_2d_face_to_3d_all_axes",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_convert_2d_face_to_3d_all_axes():\n    quad_2d = np.array([[[0, 0], [1, 0], [1, 1], [0, 1]]])\n    for axis in [0, 1, 2]:\n        result = convert_2d_face_to_3d(quad_2d, axis=axis, offset=3.5)\n        assert result.shape == (1, 4, 3)\n        assert np.allclose(result[:, :, axis], 3.5)\ndef test_convert_2d_face_to_3d_invalid_axis():\n    quad_2d = np.array([[[0, 0], [1, 0], [1, 1], [0, 1]]])\n    with pytest.raises(ValueError, match=re.escape(\"fixed_axis must be 0 (x), 1 (y), or 2 (z). Got 3.\")):\n        convert_2d_face_to_3d(quad_2d, axis=3, offset=0)",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_convert_2d_face_to_3d_invalid_axis",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_convert_2d_face_to_3d_invalid_axis():\n    quad_2d = np.array([[[0, 0], [1, 0], [1, 1], [0, 1]]])\n    with pytest.raises(ValueError, match=re.escape(\"fixed_axis must be 0 (x), 1 (y), or 2 (z). Got 3.\")):\n        convert_2d_face_to_3d(quad_2d, axis=3, offset=0)\n# --------------------------- #\n# quad_faces_from_edges Tests #\n# --------------------------- #\ndef test_quad_faces_from_edges_basic():\n    u = np.array([0, 1])\n    v = np.array([0, 1])",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_quad_faces_from_edges_basic",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_quad_faces_from_edges_basic():\n    u = np.array([0, 1])\n    v = np.array([0, 1])\n    result = quad_faces_from_edges(u, v)\n    expected = np.array([[[0, 0], [1, 0], [1, 1], [0, 1]]])\n    np.testing.assert_array_equal(result, expected)\ndef test_quad_faces_from_edges_rectangular_grid():\n    u = np.array([0, 1, 2])\n    v = np.array([0, 1])\n    result = quad_faces_from_edges(u, v)",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_quad_faces_from_edges_rectangular_grid",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_quad_faces_from_edges_rectangular_grid():\n    u = np.array([0, 1, 2])\n    v = np.array([0, 1])\n    result = quad_faces_from_edges(u, v)\n    assert result.shape == (2, 4, 2)\ndef test_quad_faces_from_edges_zero_area():\n    u = np.array([0])\n    v = np.array([0])\n    result = quad_faces_from_edges(u, v)\n    assert result.shape == (0, 4, 2)",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_quad_faces_from_edges_zero_area",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_quad_faces_from_edges_zero_area():\n    u = np.array([0])\n    v = np.array([0])\n    result = quad_faces_from_edges(u, v)\n    assert result.shape == (0, 4, 2)\n# --------------------------- #\n# mesh_between_edges Tests    #\n# --------------------------- #\ndef test_mesh_between_edges_basic():\n    edge_start = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]).T",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_mesh_between_edges_basic",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_mesh_between_edges_basic():\n    edge_start = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]).T\n    edge_end = np.array([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]).T\n    edges = np.stack([edge_start, edge_end])\n    result = mesh_between_edges(edges, radial_resolution=3)\n    assert result.shape == (4 * 2 + 1, 4, 2)  # (n_segments * (radial_resolution-1), 4, 2)\ndef test_mesh_between_edges_invalid_shape():\n    edge_start = np.array([0, 0, 0])\n    edge_end = np.array([0, 0.5, 0])\n    edges = np.stack([edge_start, edge_end], axis=1)  # wrong shape (2, 2, 2)  should be (2, N, 2)",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_mesh_between_edges_invalid_shape",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_mesh_between_edges_invalid_shape():\n    edge_start = np.array([0, 0, 0])\n    edge_end = np.array([0, 0.5, 0])\n    edges = np.stack([edge_start, edge_end], axis=1)  # wrong shape (2, 2, 2)  should be (2, N, 2)\n    with pytest.raises(ValueError, match=re.escape(\"edges must have shape (2, axis_count, vertex_count)\")):\n        mesh_between_edges(edges, radial_resolution=3)\ndef test_mesh_between_edges_invalid_resolution():\n    edge_start = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])\n    edge_end = np.array([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]])\n    edges = np.stack([edge_start, edge_end])",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_mesh_between_edges_invalid_resolution",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_mesh_between_edges_invalid_resolution():\n    edge_start = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])\n    edge_end = np.array([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]])\n    edges = np.stack([edge_start, edge_end])\n    with pytest.raises(ValueError, match=\"radial_resolution must be at least 1\"):\n        mesh_between_edges(edges, radial_resolution=0)\n# --------------------------- #\n# rectangle_perimeter Tests   #\n# --------------------------- #\ndef test_rectangle_perimeter_basic():",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_rectangle_perimeter_basic",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_rectangle_perimeter_basic():\n    length_edge = np.array([0.0, 1.0])\n    width_edge = np.array([0.0, 1.0])\n    result = rectangle_perimeter(length_edge, width_edge)\n    assert result.shape == (2, 5)\ndef test_rectangle_perimeter_invalid_dimensions():\n    length_edge = np.array([[0, 1]])\n    width_edge = np.array([0, 1])\n    with pytest.raises(ValueError, match=\"length_edge and width_edge must have the same shape.\"):\n        rectangle_perimeter(length_edge, width_edge)",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_rectangle_perimeter_invalid_dimensions",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_rectangle_perimeter_invalid_dimensions():\n    length_edge = np.array([[0, 1]])\n    width_edge = np.array([0, 1])\n    with pytest.raises(ValueError, match=\"length_edge and width_edge must have the same shape.\"):\n        rectangle_perimeter(length_edge, width_edge)\ndef test_rectangle_perimeter_too_few_points():\n    length_edge = np.array([0.0])\n    width_edge = np.array([0.0, 1.0])\n    with pytest.raises(ValueError, match=\"length_edge and width_edge must have at least 2 points\"):\n        rectangle_perimeter(length_edge, width_edge)",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_rectangle_perimeter_too_few_points",
        "kind": 2,
        "importPath": "tests.test_edge",
        "description": "tests.test_edge",
        "peekOfCode": "def test_rectangle_perimeter_too_few_points():\n    length_edge = np.array([0.0])\n    width_edge = np.array([0.0, 1.0])\n    with pytest.raises(ValueError, match=\"length_edge and width_edge must have at least 2 points\"):\n        rectangle_perimeter(length_edge, width_edge)",
        "detail": "tests.test_edge",
        "documentation": {}
    },
    {
        "label": "test_revolve_curve_along_path_basic",
        "kind": 2,
        "importPath": "tests.test_revolve",
        "description": "tests.test_revolve",
        "peekOfCode": "def test_revolve_curve_along_path_basic():\n    curve = np.array([[1, 2], [3, 4]])\n    revolve_path = np.array([[0, 1], [np.pi/2, 2]])\n    mesh = revolve_curve_along_path(curve, revolve_path)\n    assert isinstance(mesh, np.ndarray)\n    assert mesh.shape == (1, 4, 3)\ndef test_revolve_curve_along_path_multiple_segments():\n    curve = np.array([[0, 0], [1, 1], [2, 0]])\n    revolve_path = np.array([[0, 1], [np.pi/2, 2], [np.pi, 3]])\n    mesh = revolve_curve_along_path(curve, revolve_path)",
        "detail": "tests.test_revolve",
        "documentation": {}
    },
    {
        "label": "test_revolve_curve_along_path_multiple_segments",
        "kind": 2,
        "importPath": "tests.test_revolve",
        "description": "tests.test_revolve",
        "peekOfCode": "def test_revolve_curve_along_path_multiple_segments():\n    curve = np.array([[0, 0], [1, 1], [2, 0]])\n    revolve_path = np.array([[0, 1], [np.pi/2, 2], [np.pi, 3]])\n    mesh = revolve_curve_along_path(curve, revolve_path)\n    assert mesh.shape == ((3-1)*(3-1), 4, 3)  # (m-1)*(n-1)\ndef test_revolve_curve_along_path_invalid_curve_shape():\n    curve = np.array([1, 2, 3])  # 1D\n    revolve_path = np.array([[0, 1], [np.pi/2, 2]])\n    with pytest.raises(ValueError, match=\"Curve must be a \\\\(n, 2\\\\) array\"):\n        revolve_curve_along_path(curve, revolve_path)",
        "detail": "tests.test_revolve",
        "documentation": {}
    },
    {
        "label": "test_revolve_curve_along_path_invalid_curve_shape",
        "kind": 2,
        "importPath": "tests.test_revolve",
        "description": "tests.test_revolve",
        "peekOfCode": "def test_revolve_curve_along_path_invalid_curve_shape():\n    curve = np.array([1, 2, 3])  # 1D\n    revolve_path = np.array([[0, 1], [np.pi/2, 2]])\n    with pytest.raises(ValueError, match=\"Curve must be a \\\\(n, 2\\\\) array\"):\n        revolve_curve_along_path(curve, revolve_path)\ndef test_revolve_curve_along_path_invalid_revolve_path_shape():\n    curve = np.array([[1, 2], [3, 4]])\n    revolve_path = np.array([0, 1])  # 1D\n    with pytest.raises(ValueError, match=\"Revolve path must be a \\\\(m, 2\\\\) array\"):\n        revolve_curve_along_path(curve, revolve_path)",
        "detail": "tests.test_revolve",
        "documentation": {}
    },
    {
        "label": "test_revolve_curve_along_path_invalid_revolve_path_shape",
        "kind": 2,
        "importPath": "tests.test_revolve",
        "description": "tests.test_revolve",
        "peekOfCode": "def test_revolve_curve_along_path_invalid_revolve_path_shape():\n    curve = np.array([[1, 2], [3, 4]])\n    revolve_path = np.array([0, 1])  # 1D\n    with pytest.raises(ValueError, match=\"Revolve path must be a \\\\(m, 2\\\\) array\"):\n        revolve_curve_along_path(curve, revolve_path)\n# ----------------------------- #\n# circular_revolve tests        #\n# ----------------------------- #\ndef test_circular_revolve_basic():\n    curve = np.array([",
        "detail": "tests.test_revolve",
        "documentation": {}
    },
    {
        "label": "test_circular_revolve_basic",
        "kind": 2,
        "importPath": "tests.test_revolve",
        "description": "tests.test_revolve",
        "peekOfCode": "def test_circular_revolve_basic():\n    curve = np.array([\n        [1.0, 0.0],\n        [2.0, 1.0],\n    ])\n    segment_resolution = 8\n    mesh = circular_revolve(curve, segment_resolution)\n    assert isinstance(mesh, np.ndarray)\n    assert mesh.shape == (8 * (2-1), 4, 3)  # (segments * (n-1))\ndef test_circular_revolve_full_circle():",
        "detail": "tests.test_revolve",
        "documentation": {}
    },
    {
        "label": "test_circular_revolve_full_circle",
        "kind": 2,
        "importPath": "tests.test_revolve",
        "description": "tests.test_revolve",
        "peekOfCode": "def test_circular_revolve_full_circle():\n    curve = np.array([\n        [1.0, 0.0],\n        [2.0, 1.0],\n        [2.5, 2.0],\n    ])\n    segment_resolution = 12\n    mesh = circular_revolve(curve, segment_resolution)\n    assert mesh.shape == (12 * (3-1), 4, 3)\ndef test_circular_revolve_partial_revolve():",
        "detail": "tests.test_revolve",
        "documentation": {}
    },
    {
        "label": "test_circular_revolve_partial_revolve",
        "kind": 2,
        "importPath": "tests.test_revolve",
        "description": "tests.test_revolve",
        "peekOfCode": "def test_circular_revolve_partial_revolve():\n    curve = np.array([\n        [1.0, 0.0],\n        [2.0, 1.0],\n    ])\n    segment_resolution = 4\n    mesh = circular_revolve(curve, segment_resolution, start_angle=0, end_angle=np.pi)\n    assert mesh.shape == (4 * (2-1), 4, 3)\ndef test_circular_revolve_invalid_curve_shape():\n    curve = np.array([1.0, 2.0])  # 1D",
        "detail": "tests.test_revolve",
        "documentation": {}
    },
    {
        "label": "test_circular_revolve_invalid_curve_shape",
        "kind": 2,
        "importPath": "tests.test_revolve",
        "description": "tests.test_revolve",
        "peekOfCode": "def test_circular_revolve_invalid_curve_shape():\n    curve = np.array([1.0, 2.0])  # 1D\n    with pytest.raises(ValueError, match=\"curve must be a \\\\(n, 2\\\\) array\"):\n        circular_revolve(curve, segment_resolution=8)\ndef test_circular_revolve_invalid_segment_resolution():\n    curve = np.array([\n        [1.0, 0.0],\n        [2.0, 1.0],\n    ])\n    with pytest.raises(ValueError, match=\"segment_resolution must be at least 1\"):",
        "detail": "tests.test_revolve",
        "documentation": {}
    },
    {
        "label": "test_circular_revolve_invalid_segment_resolution",
        "kind": 2,
        "importPath": "tests.test_revolve",
        "description": "tests.test_revolve",
        "peekOfCode": "def test_circular_revolve_invalid_segment_resolution():\n    curve = np.array([\n        [1.0, 0.0],\n        [2.0, 1.0],\n    ])\n    with pytest.raises(ValueError, match=\"segment_resolution must be at least 1\"):\n        circular_revolve(curve, segment_resolution=0)\n# ----------------------------- #\n# Randomized property test      #\n# ----------------------------- #",
        "detail": "tests.test_revolve",
        "documentation": {}
    },
    {
        "label": "test_circular_revolve_randomized",
        "kind": 2,
        "importPath": "tests.test_revolve",
        "description": "tests.test_revolve",
        "peekOfCode": "def test_circular_revolve_randomized(segments):\n    np.random.seed(42)\n    curve = np.random.rand(5, 2)  # Random 5-point curve\n    mesh = circular_revolve(curve, segments)\n    assert mesh.shape == (segments * (5-1), 4, 3)\n    assert np.isfinite(mesh).all()",
        "detail": "tests.test_revolve",
        "documentation": {}
    },
    {
        "label": "test_sphere_projection_basic",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_projection_basic() -> None:\n    radius = 1.0\n    resolution = 10\n    mesh = sphere_mesher_from_projection(radius, resolution)\n    assert isinstance(mesh, np.ndarray)\n    assert mesh.ndim == 3\n    assert mesh.shape[1:] == (4, 3)\n    np.testing.assert_allclose(np.linalg.norm(mesh, axis=2), radius)\ndef test_sphere_projection_invalid_radius() -> None:\n    with pytest.raises(ValueError, match=\"Radius must be positive\"):",
        "detail": "tests.test_sphere",
        "documentation": {}
    },
    {
        "label": "test_sphere_projection_invalid_radius",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_projection_invalid_radius() -> None:\n    with pytest.raises(ValueError, match=\"Radius must be positive\"):\n        sphere_mesher_from_projection(0, 10)\n    with pytest.raises(ValueError, match=\"Radius must be positive\"):\n        sphere_mesher_from_projection(-1, 10)\ndef test_sphere_projection_invalid_resolution() -> None:\n    with pytest.raises(ValueError, match=\"resolution must be at least 1\"):\n        sphere_mesher_from_projection(1.0, 0)\n    with pytest.raises(ValueError, match=\"resolution must be at least 1\"):\n        sphere_mesher_from_projection(1.0, -5)",
        "detail": "tests.test_sphere",
        "documentation": {}
    },
    {
        "label": "test_sphere_projection_invalid_resolution",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_projection_invalid_resolution() -> None:\n    with pytest.raises(ValueError, match=\"resolution must be at least 1\"):\n        sphere_mesher_from_projection(1.0, 0)\n    with pytest.raises(ValueError, match=\"resolution must be at least 1\"):\n        sphere_mesher_from_projection(1.0, -5)\ndef test_sphere_projection_shape_scaling() -> None:\n    radius = 3.5\n    resolution = 5\n    mesh = sphere_mesher_from_projection(radius, resolution)\n    np.testing.assert_allclose(np.linalg.norm(mesh, axis=2), radius)",
        "detail": "tests.test_sphere",
        "documentation": {}
    },
    {
        "label": "test_sphere_projection_shape_scaling",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_projection_shape_scaling() -> None:\n    radius = 3.5\n    resolution = 5\n    mesh = sphere_mesher_from_projection(radius, resolution)\n    np.testing.assert_allclose(np.linalg.norm(mesh, axis=2), radius)\n# ------------------------------ #\n# sphere_mesher_from_radial tests\n# ------------------------------ #\ndef test_sphere_radial_basic() -> None:\n    radius = 1.0",
        "detail": "tests.test_sphere",
        "documentation": {}
    },
    {
        "label": "test_sphere_radial_basic",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_radial_basic() -> None:\n    radius = 1.0\n    radial_resolution = 10\n    segment_resolution = 10\n    mesh = sphere_mesher_from_radial(radius, radial_resolution, segment_resolution)\n    assert isinstance(mesh, np.ndarray)\n    assert mesh.ndim == 3\n    assert mesh.shape == (radial_resolution * segment_resolution, 4, 3)\ndef test_sphere_radial_partial_angle() -> None:\n    radius = 1.0",
        "detail": "tests.test_sphere",
        "documentation": {}
    },
    {
        "label": "test_sphere_radial_partial_angle",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_radial_partial_angle() -> None:\n    radius = 1.0\n    radial_resolution = 5\n    segment_resolution = 8\n    mesh = sphere_mesher_from_radial(radius, radial_resolution, segment_resolution, start_angle=0, end_angle=np.pi)\n    assert mesh.shape == (radial_resolution * segment_resolution, 4, 3)\ndef test_sphere_radial_invalid_radius() -> None:\n    with pytest.raises(ValueError, match=\"Radius must be positive\"):\n        sphere_mesher_from_radial(0, 10, 10)\ndef test_sphere_radial_invalid_radial_resolution() -> None:",
        "detail": "tests.test_sphere",
        "documentation": {}
    },
    {
        "label": "test_sphere_radial_invalid_radius",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_radial_invalid_radius() -> None:\n    with pytest.raises(ValueError, match=\"Radius must be positive\"):\n        sphere_mesher_from_radial(0, 10, 10)\ndef test_sphere_radial_invalid_radial_resolution() -> None:\n    with pytest.raises(ValueError, match=\"radial_resolution must be at least 1\"):\n        sphere_mesher_from_radial(1.0, 0, 10)\ndef test_sphere_radial_invalid_segment_resolution() -> None:\n    with pytest.raises(ValueError, match=\"segment_resolution must be at least 1\"):\n        sphere_mesher_from_radial(1.0, 10, 0)\n@pytest.mark.parametrize(\"radius\", [0.5, 1.0, 10.0])",
        "detail": "tests.test_sphere",
        "documentation": {}
    },
    {
        "label": "test_sphere_radial_invalid_radial_resolution",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_radial_invalid_radial_resolution() -> None:\n    with pytest.raises(ValueError, match=\"radial_resolution must be at least 1\"):\n        sphere_mesher_from_radial(1.0, 0, 10)\ndef test_sphere_radial_invalid_segment_resolution() -> None:\n    with pytest.raises(ValueError, match=\"segment_resolution must be at least 1\"):\n        sphere_mesher_from_radial(1.0, 10, 0)\n@pytest.mark.parametrize(\"radius\", [0.5, 1.0, 10.0])\ndef test_sphere_radial_radius_variations(radius) -> None:\n    mesh = sphere_mesher_from_radial(radius, 5, 8)\n    norms = np.linalg.norm(mesh, axis=2)",
        "detail": "tests.test_sphere",
        "documentation": {}
    },
    {
        "label": "test_sphere_radial_invalid_segment_resolution",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_radial_invalid_segment_resolution() -> None:\n    with pytest.raises(ValueError, match=\"segment_resolution must be at least 1\"):\n        sphere_mesher_from_radial(1.0, 10, 0)\n@pytest.mark.parametrize(\"radius\", [0.5, 1.0, 10.0])\ndef test_sphere_radial_radius_variations(radius) -> None:\n    mesh = sphere_mesher_from_radial(radius, 5, 8)\n    norms = np.linalg.norm(mesh, axis=2)\n    np.testing.assert_allclose(norms, radius)\n# ------------------------------ #\n# randomized stress test",
        "detail": "tests.test_sphere",
        "documentation": {}
    },
    {
        "label": "test_sphere_radial_radius_variations",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_radial_radius_variations(radius) -> None:\n    mesh = sphere_mesher_from_radial(radius, 5, 8)\n    norms = np.linalg.norm(mesh, axis=2)\n    np.testing.assert_allclose(norms, radius)\n# ------------------------------ #\n# randomized stress test\n# ------------------------------ #\ndef test_sphere_projection_randomized() -> None:\n    np.random.seed(0)\n    radius = np.random.uniform(0.5, 5.0)",
        "detail": "tests.test_sphere",
        "documentation": {}
    },
    {
        "label": "test_sphere_projection_randomized",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_projection_randomized() -> None:\n    np.random.seed(0)\n    radius = np.random.uniform(0.5, 5.0)\n    resolution = np.random.randint(3, 20)\n    mesh = sphere_mesher_from_projection(radius, resolution)\n    assert mesh.shape[1:] == (4, 3)\n    assert np.isfinite(mesh).all()\ndef test_sphere_radial_randomized() -> None:\n    np.random.seed(1)\n    radius = np.random.uniform(0.5, 5.0)",
        "detail": "tests.test_sphere",
        "documentation": {}
    },
    {
        "label": "test_sphere_radial_randomized",
        "kind": 2,
        "importPath": "tests.test_sphere",
        "description": "tests.test_sphere",
        "peekOfCode": "def test_sphere_radial_randomized() -> None:\n    np.random.seed(1)\n    radius = np.random.uniform(0.5, 5.0)\n    radial_res = np.random.randint(3, 15)\n    segment_res = np.random.randint(5, 20)\n    mesh = sphere_mesher_from_radial(radius, radial_res, segment_res)\n    assert mesh.shape == (radial_res * segment_res, 4, 3)\n    assert np.isfinite(mesh).all()",
        "detail": "tests.test_sphere",
        "documentation": {}
    }
]